<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Aurelia Presentation</title>

		<meta name="description" content="Aurelia is a JavaScript client framework for mobile, desktop and web leveraging simple conventions and empowering creativity">
		<meta name="author" content="Daniela Baron">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<!-- Reveal -->
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Font Awesome -->
		<script src="https://use.fontawesome.com/b6bf245f2c.js"></script>

		<!-- Custom styles -->
		<link rel="stylesheet" href="css/custom.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">

				<!-- Intro -->
				<section>
					<a href="#" class="navigate-down">
						<img width="573" height="170" data-src="images/aurelia-logo.png" alt="Aurelia Logo"
							style="border: none; background: none; box-shadow: none;">
					</a>
					<h3>A JavaScript Client Framework</h3>
					<p>
						<small>Presented by:
						<ul>
							<li><a href="https://github.com/Ghnuberath">Sean McIntyre</a></li>
							<li><a href="https://github.com/mlaccetti">Michael Laccetti</a></li>
							<li><a href="https://github.com/danielabar">Daniela Baron</a></li>
						</ul>
						</small>
					</p>
				</section>

				<!-- TODO: Why this talk? -->

				<!-- Connector -->
				<section>
					<h2>Learn ES2015, Quickly</h2>
					<hr>
					<h2 style="color:grey">Aurelia Overview</h2>
					<hr>
					<h2 style="color:grey">Testing</h2>
				</section>

				<!-- BEGIN Sean: ES2015 Overview -->
				<section>
					<section>
						<h2>Learn ES2015, Quickly!</h2>
						<h5>Also ES2016, sometimes called ES6/7.</h5>
						<p>
							JavaScript that doesn't suck :)
						</p>
					</section>
					<section>
						<h2><code>var</code> is dead.<br/>Long live <code>let</code> &amp; <code>const</code></h2>
					</section>
					<section>
						<h3>Constants!</h3>
						<pre class="presentation-code"><code class="hljs" data-trim>
var pi = 3.141592653;
// is now
const pi = 3.141592653;
						</code></pre>
					</section>
					<section>
						<h3>Block scoping!</h3>
						<pre class="presentation-code fragment"><code class="hljs" data-trim>
// this works. stop the insanity.
for (var i=0; i<10; i++) {
	console.log(i);
}
console.log(i);
						</code></pre>
						<pre class="presentation-code fragment"><code class="hljs" data-trim>
// this does not work :)
for (let i=0; i<10; i++) {
	console.log(i);
}
console.log(i);
					</code></pre>
					</section>
					<section>
						<h2>Arrow Notation</h2>
						<pre class="presentation-code fragment"><code class="hljs" data-trim>
[1,2,3].map(a => a+1);
					  </code></pre>
						<div class="fragment">
							<h3>Lexical <code>this</code></h3>
							<pre class="presentation-code fragment"><code class="hljs" data-trim>
function() {
	var self = this;
	self.name = 'Sean';
	setInterval(function() {
		console.log(self.name); // ugly :(
	});
}
						  </code></pre>
							<pre class="presentation-code fragment"><code class="hljs" data-trim>
function() {
	this.name = 'Sean';
	setInterval(() => {
		console.log(this.name); // => shares the same this
		                        // with the surrounding code!
	});
}
						  </code></pre>
						</div>
					</section>
					<section>
						<h2>Classes<br/><small class="fragment">(finally)</small></h2>
					</section>
					<section>
						<pre class="presentation-code"><code class="hljs" data-trim>
class Person {
	constructor(firstName, lastName) {
		this.firstName = firstName;
		this.lastName = lastName;
	}
	getFullName() {
		return this.firstName + ' ' + this.lastName;
	}
}
						</code></pre>
					</section>
					<section>
						<pre class="presentation-code"><code class="hljs" data-trim>
class Developer extends Person {
	// static method called with Developer.curse();
	static curse() { return 'thou shalt forever be off by one...'; }

	constructor(firstName, lastName, isRemote) {
		super(firstName, lastName);
		this._isRemote = isRemote;
	}

	// getter, used via developerInstance.isRemote
	get isRemote() { return this._isRemote; }
	// setter, used via developerInstance.isRemote = false
	set isRemote(newIsRemote) {
		throw new Error('Cannot re-assign isRemote!');
	}
}
						</code></pre>
					</section>
					<section>
						<h2>Decorators</h2>
						<pre class="presentation-code fragment"><code class="hljs" data-trim>
@isTestable(true)
class Person {
	constructor(firstName, lastName) {
		this.firstName = firstName;
		this.lastName = lastName;
	}
	@readonly
	getFullName() {
		return this.firstName + ' ' + this.lastName;
	}
}
						</code></pre>
						<div class="fragment">
							<p>
								Decorators are annotations which allow you to define cross-cutting modifications to classes and methods.
							</p>
							<p>
								Decorators are executed at runtime.
							</p>
						</div>
					</section>
					<section>
						<p>
							Built-in classes like <code>Array</code>, <code>Date</code> and DOM <code>Element</code>s can be subclassed!
						</p>
					</section>
					<section>
						<h2>Modules</h2>
						<p class="fragment">
							Making module syntax a native part of the language!
						</p>
						<pre class="presentation-code fragment"><code class="hljs" data-trim>
// lib/math.js
export function sum(x, y) {
  return x + y;
}
export var pi = 3.141593;
						</code></pre>
						<pre class="presentation-code fragment"><code class="hljs" data-trim>
// app.js
import * as math from "lib/math";
alert("2π = " + math.sum(math.pi, math.pi));
						</code></pre>
						<pre class="presentation-code fragment"><code class="hljs" data-trim>
// otherApp.js
import {sum, pi} from "lib/math";
alert("2π = " + sum(pi, pi));
						</code></pre>
					</section>
					<section>
						<h2>Template strings</h2>
						<pre class="presentation-code fragment"><code class="hljs" data-trim>
/* before, in Person, we had this: */
getFullName() {
	return this.firstName + ' ' + this.lastName;
}
						</code></pre>
						<pre class="presentation-code fragment"><code class="hljs" data-trim>
/* now we can do this!*/
getFullName() {
	return `${this.firstName} ${this.lastName}`;
}
						</code></pre>
					</section>
					<section>
						<h2>for...of (Iterators)</h2>
						<pre class="presentation-code fragment"><code class="hljs" data-trim>
let a = ['a','b','c'];
						</code></pre>
						<pre class="presentation-code fragment"><code class="hljs" data-trim>
for (let i in a) {
  console.log(i);
}
// prints 0 1 2 (which is pretty useless)
						</code></pre>
						<pre class="presentation-code fragment"><code class="hljs" data-trim>
for (let i of a) {
	console.log(prop);
}
// prints a b c :)
						</code></pre>
						<p class="fragment">
							You can use the Iterator protocol in your own functions and classes to make anything iterable via <code>for...of</code>
						</p>
					</section>
					<section>
						<h2>Default, Rest and Spread</h2>
						<pre class="presentation-code fragment"><code class="hljs" data-trim>
function f(x, y=12) {
  // y is 12 if not passed (or passed as undefined)
  return x + y;
}
f(3) == 15
						</code></pre>
						<pre class="presentation-code fragment"><code class="hljs" data-trim>
function f(x, ...y) {
  // y is an Array
  return x * y.length;
}
f(3, "hello", true) == 6
						</code></pre>
						<pre class="presentation-code fragment"><code class="hljs" data-trim>
function f(x, y, z) {
  return x + y + z;
}
// Pass each elem of array as argument
f(...[1,2,3]) == 6
						</code></pre>
					</section>
					<section>
						<h2>Destructuring</h2>
						<pre class="presentation-code fragment"><code class="hljs" data-trim>
let a, b, rest;

[a, b] = [1, 2]
{a, b} = {a:1, b:2}
// a === 1, b === 2

[a, b, ...rest] = [1, 2, 3, 4, 5]
// a === 1, b === 2, rest === [3,4,5]
						</code></pre>
					</section>
					<section>
						<h2>Destructuring<br/> <small>(multiple return values)</small></h2>
						<pre class="presentation-code"><code class="hljs" data-trim>
function f() {
	return [1,2];
}
[a, b] = f();
						</code></pre>
					</section>
					<section>
						<h2><code>Set</code>s and <code>Map</code>s</h2>
						<pre class="presentation-code fragment"><code class="hljs" data-trim>
const s = new Set();
s.add("hello").add("goodbye").add("hello");
s.size === 2;
s.has("hello") === true;
						</code></pre>
						<pre class="presentation-code fragment"><code class="hljs" data-trim>
const m = new Map();
m.set("hello", 42);
m.set("goodbye", 34);
m.get("goodbye") == 34;
						</code></pre>
					</section>
					<section>
						<h2><code>WeakMap</code>s and <code>WeakSet</code>s</h2>
						<pre class="presentation-code fragment"><code class="hljs" data-trim>
const obj = {
	// ...
}
						</code></pre>
						<pre class="presentation-code fragment"><code class="hljs" data-trim>
const wm = new WeakMap();
wm.set(obj, 42); // store some metadata about obj.
						</code></pre>
						<ul>
							<li class="fragment">Keys in a <code>WeakMap</code> must be objects</li>
							<li class="fragment"><code>WeakMap</code>s do not hold a strong reference to their keys.</li>
							<li class="fragment">Great way to store additional metadata on an object without polluting it.</li>
							<li class="fragment">WeakSets are similar</li>
						</ul>
					</section>
					<section>
						<h2>Native <code>Promise</code>s</h2>
						<pre class="presentation-code fragment"><code class="hljs" data-trim>
const p = new Promise((resolve, reject) => {
	setTimeout(() => {
		Math.random() < 0.5 ? resolve() : reject();
	}, 500);
});

p.then(() => {
	console.log('Resolved!');
})
.catch(() => {
	console.log('Rejected!');
});
						</code></pre>
					</section>
					<section>
						<h2>Generators</h2>
						<pre class="presentation-code fragment"><code class="hljs" data-trim>
function *getTime() {
	while(true) {
		yield Date.now();
	}
}
const timer = getTime();
console.log(timer.next()); // { value: 1454906307698, done: false }
console.log(timer.next()); // { value: 1454906307710, done: false }
console.log(timer.next()); // { value: 1454906307711, done: false }
						</code></pre>
						<p class="fragment">You can also use the <code>for...of</code> loop with Generators :)</p>
					</section>
					<section>
						<h2>Generators<br/><small>two-way communication</small></h2>
						<pre class="presentation-code fragment"><code class="hljs" data-trim>
const summer = (function *sum() {
	let sum = 0;
	while(true) {
		sum += yield sum;
	}
})();
summer.next(); // start summer by making it yield once
// now we can pump values into it, and receive the current sum
console.log(summer.next(1)); // { value: 1, done: false }
console.log(summer.next(2)); // { value: 3, done: false }
console.log(summer.next(3)); // { value: 6, done: false }
						</code></pre>
						<p class="fragment"><small>Calling <code>next()</code> on a generator makes it pause execution. When the generator is restarted by another call to <code>next()</code>, the argument passed to <code>next()</code> replaces the yield expression.</small></p>
					</section>
					<section>
						<h2>Now for the crazy part...</h2>
					</section>
					<section>
						<h2>Generators</br><small>as a way to avoid callbacks</small></h2>
						<div class="fragment">
							<p>
								 Let's say we have some asynchronous function<br/> returning a Promise:
							</p>
							<pre class="presentation-code"><code class="hljs" data-trim>
function longRunning(done) {
	return new Promise((resolve) => {
		setTimeout(() => {
			resolve(Math.random());
		}, 500);
	});
}
							</code></pre>
						</div>
					</section>
					<section>
						<p>Normally, we'd use it like this:</p>
						<pre class="presentation-code"><code class="hljs" data-trim>
longRunning.then((result) => {
	console.log(result);
})
						</code></pre>
					</section>
					<section>
						<div>
							<p>But now we can do something like this...</p>
							<pre class="presentation-code"><code class="hljs" data-trim>
const script = function *() {
	let s = yield longRunning();
	console.log(s);
}();
							</code></pre>
						</div>
						<div class="fragment">
							<p>With the assistance of this horrifying statement:</p>
							<pre class="presentation-code"><code class="hljs" data-trim>
script.next().value.then((r) => {
	script.next(r);
});
							</code></pre>
						</div>
					</section>
					<section>
						<p>
							Treating async code like it's synchronous is awesome!
						</p>
						<pre class="presentation-code"><code class="hljs" data-trim>
const script = function *() {
	let s = yield longRunning(); // so cool!
	console.log(s);
}();
						</code></pre>
						<p class="fragment">
							So how do we avoid the horror?
						</p>
					</section>
					<section>
						<h2>ES2016 <code>async...await</code></h2>
						<div class="fragment">
							<pre class="presentation-code"><code class="hljs" data-trim>
const script = function *() {
	let s = yield longRunning();
	console.log(s);
}();
script.next().value.then((r) => {
	script.next(r);
});
							</code></pre>
						</div>
						<p class="fragment">
							becomes...
						</p>
						<div class="fragment">
							<pre class="presentation-code"><code class="hljs" data-trim>
(async function script() {
	let s = await longRunning(); // even cooler!
	console.log(s);
})();
// no ugliness!
							</code></pre>
						</div>
					</section>
					<section>
						<p>
							Or, more realistically...
						</p>
						<pre class="presentation-code fragment"><code class="hljs" data-trim>
(async function script() {
	try {
		let s = await longRunning(); // sequential async
		let t = await anotherLongRunning();
		console.log(s + t);
	} catch (err) {
		console.error(err);
	}
})();
						</code></pre>
						<p class="fragment">
							Notice that good old-fashioned <code>try-catch</code> blocks work again!
						</p>
					</section>
					<section>
						<p>
							Or, for parallel async
						</p>
						<pre class="presentation-code fragment"><code class="hljs" data-trim>
(async function script() {
	try {
		let [s,t] = await Promise.all(
			longRunning(),
			anotherLongRunning()
		);
		console.log(s + t);
	} catch (err) {
		console.error(err);
	}
})();
						</code></pre>
					</section>
					<section>
						<p>Almost all of this is available in Node.js natively, right now!</p>
						<p class="fragment">
							If you're not using it...start. My eyes will thank you.
						</p>
						<div class="fragment">
							<p>
								If you want to use this in the browser, you'll need to use a <strong>transpiler</strong> until the ES2015 and ES2016 specifications are implemented natively. Popular transpilers include:
							</p>
							<ul>
								<li><a href="http://babeljs.io/">Babel</a></li>
								<li><a href="https://github.com/google/traceur-compiler">Traceur</a></li>
							</ul>
						</div>
					</section>
					<section>
						<h2>ES2015/ES2016<br/><small>Further reading</small></h2>
						<p>
							For more information, the <a href="http://babeljs.io/docs/learn-es2015/">Babel docs</a> are a good reference
						</p>
						<p>
							As is the Mozilla Developer Network <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference">JavaScript reference</a>
						</p>
						<div class="fragment">
							Stuff I didn't cover:
							<ul>
								<li>Symbols (new basic type, allowing private class members)</li>
								<li>Proxies</li>
								<li>New Math, Number, String and Object APIs</li>
								<li>Binary and Octal literals</li>
								<li>Reflection API</li>
								<li>Tail recursion</li>
							</ul>
						</div>
					</section>
				</section>
				<!-- END Sean: ES6 Overview -->

				<!-- Connector -->
				<section>
					<h2 style="color:grey">Learn ES2015, Quickly</h2>
					<hr>
					<h2>Aurelia Overview</h2>
					<hr>
					<h2 style="color:grey">Testing</h2>
				</section>

				<!-- BEGIN Mike: Aurelia Overview -->
				<section>
					<section>
						<h2>Aurelia Overview</h2>
					</section>
					<section>
						<h2>MVVM</h2>
					</section>
					<section>
						<h2>Dependency Injection</h2>
					</section>
					<section>
						<h2>Routing</h2>
					</section>
					<section>
						<h2>Data Binding</h2>
					</section>
					<section>
						<h2>Events</h2>
					</section>
					<section>
						<h2>Custom Elements and Attributes</h2>
					</section>
					<section>
						<h2>Preparing for Production</h2>
					</section>
				</section>

				<!-- Connector -->
				<section>
					<h2 style="color:grey">Learn ES2015, Quickly</h2>
					<hr>
					<h2 style="color:grey">Aurelia Overview</h2>
					<hr>
					<h2>Testing</h2>
				</section>

				<!-- BEGIN Daniela: Testing -->
				<section>
					<section data-state="side-by-side">
						<h2>Unit Testing with Aurelia</h2>
						<h3>Good news, it's easy!</h3>
						<div class="container">
							<div class="left-side">
								<img src="images/easy.jpg" class="no-border" alt="easy">
							</div>
							<div class="right-side">
								<ul>
									<li class="fragment">No boilerplate imposed by framework <span class="fragment">(cough Angular 1)</span></li>
									<li class="fragment">Constructor based dependency injection makes it trivial to provide mock dependencies.</li>
								</ul>
							</div>
						</div>
					</section>

					<section data-state="side-by-side" data-transition="none">
						<h2>Everything is a class</h2>
						<p>A simple pattern for testing:</p>
						<div class="container">
							<div class="left-side">
								<ul>
									<li class="fragment zoom-in highlight-current-green" data-fragment-index="1">Import module</li>
									<li class="fragment zoom-in highlight-current-green" data-fragment-index="2">Describe the test</li>
									<li class="fragment zoom-in highlight-current-green" data-fragment-index="3">Instantiate class</li>
									<li class="fragment zoom-in highlight-current-green" data-fragment-index="4">Add a test</li>
									<li class="fragment zoom-in highlight-current-green" data-fragment-index="5">Invoke class methods</li>
									<li class="fragment zoom-in highlight-current-green" data-fragment-index="6">Make assertion</li>
									<li class="fragment zoom-in highlight-current-green" data-fragment-index="7">Add more tests...</li>
								</ul>
							</div>
							<div class="right-side">
								<pre class="presentation-code"><code class="hljs" data-trim  data-noescape>
<span class="fragment" data-fragment-index="1">import {Foo} from '../src/foo';</span>

<span class="fragment" data-fragment-index="2">describe('Foo', () => {</span>
	<span class="fragment" data-fragment-index="3">let foo;
	beforeEach(() => {
		foo = new Foo();
	});</span>

	<span class="fragment" data-fragment-index="4">it('Returns something', () => {</span>
		<span class="fragment" data-fragment-index="5">let result = foo.doSomething();</span>
		<span class="fragment" data-fragment-index="6">expect(result).toEqual('foo');</span>
	<span class="fragment" data-fragment-index="4">});</span>
	<span class="fragment" data-fragment-index="7">it('Something else', () => {
		// ...
	});</span>
<span class="fragment" data-fragment-index="2">});</span>
								</code></pre>
							</div>
						</div>
					</section>

					<section data-state="enough-foo" data-transition="none" data-background-transition="none" data-background-image="images/grumpy-old-guys.jpg" data-background-position="50% 50%">
						<div class="content">
							<h2>Enough with the Foo</h2>
							<h3>Let's see a real example!</h3>
						</div>
					</section>

					<section data-state="side-by-side" data-transition="none">
						<h2>Example: View Model</h2>
						<div class="container">
							<div class="left-side">
								<pre class="presentation-code"><code class="hljs" data-trim>
export class Welcome {
	constructor() {
		this.firstName = 'John';
		this.lastName = 'Doe';
	}

  get fullName() {
    return `${this.firstName}
			${this.lastName}`;
  }

  // other methods ...
}
								</code></pre>
							</div>
							<div class="right-side">
								<pre class="presentation-code"><code class="hljs" data-trim data-noescape>
<span class="fragment"  data-fragment-index="1">import {Welcome} from
	'../src/welcome.js';</span>

<span class="fragment" data-fragment-index="2">describe('Welcome', () => {</span>
  <span class="fragment" data-fragment-index="3">let welcome;
  beforeEach(() => {
    welcome = new Welcome();
  });</span>

  <span class="fragment" data-fragment-index="4">it('Returns default full name', () => {
    expect(welcome.fullName)
			.toEqual('John Doe');
  });</span>
  <span class="fragment" data-fragment-index="5">it('Returns full name', () => {
    welcome.firstName = 'Sara';
    welcome.lastName = 'Smith';
    expect(welcome.fullName)
			.toEqual('Sara Smith');
  });</span>
<span class="fragment" data-fragment-index="2">});</span>
								</code></pre>
							</div>
						</div>
					</section>

					<section data-state="enough-foo" data-transition="none" data-background-transition="none" data-background-image="images/grumpy-old-guys.jpg" data-background-position="50% 50%">
						<div class="content-single">
							<h2>We want more examples!</h2>
						</div>
					</section>

          <section data-state="side-by-side" data-transition="none">
            <h2>Example: Value Converter</h2>
						<div class="container">
							<div class="left-side">
								<pre class="presentation-code"><code class="hljs" data-trim>
import moment from 'moment';

export class DateFormatValueConverter {
	toView(value) {
		if (value) {
			return moment(value)
				.format('MMMM Do YYYY');
		} else {
			return '';
		}
	}
}
								</code></pre>
							</div>
							<div class="right-side">
								<pre class="presentation-code"><code class="hljs" data-trim data-noescape>
<span class="fragment" data-fragment-index="1">import {DateFormatValueConverter} from
	'../src/date-format.js';</span>

<span class="fragment" data-fragment-index="2">describe('DateFormatValueConverter', () => {</span>
	<span class="fragment" data-fragment-index="3">let dateFormat;
	beforeEach(() => {
		dateFormat =
			new DateFormatValueConverter();
	});</span>

	<span class="fragment" data-fragment-index="4">it('Returns a formatted date', () => {
		let value = '2016-04-30';
    expect(dateFormat.toView(value))
			.toEqual('April 30th 2016');
	});</span>
	<span class="fragment" data-fragment-index="5">it('Returns empty string when no value', () => {
		expect(dateFormat.toView())
			.toEqual('');
	});</span>
<span class="fragment" data-fragment-index="2">});<span>
								</code></pre>
							</div>
						</div>
          </section>

					<section data-state="enough-foo" data-transition="none" data-background-transition="none" data-background-image="images/grumpy-old-guys.jpg" data-background-position="50% 50%">
						<div class="content-single">
							<h2>What about mocking dependencies?</h2>
						</div>
					</section>

					<section data-state="side-by-side">
						<h2>Example: Mocking Dependencies</h2>
						<div class="container">
							<div class="left-side">
								<pre class="presentation-code"><code class="hljs" data-trim data-noescape>
import moment from 'moment';
<span class="fragment" data-fragment-index="1">import {inject} from 'aurelia-framework';</span>
<span class="fragment" data-fragment-index="1">import {AppConfig} from './app-config';</span>

<span class="fragment" data-fragment-index="1">@inject(AppConfig)</span>
export class DateFormatValueConverter {
  <span class="fragment" data-fragment-index="2">constructor(appConfig) {
    this.appConfig = appConfig;
  }</span>
  toView(value) {
    let result = '';
    if (value) {
      result = moment(value)
				// .format('MMMM Do YYYY');
				<span class="fragment" data-fragment-index="3">.format(this.appConfig.getDateFormat());</span>
    }
    return result;
  }
}
								</code></pre>
							</div>
							<div class="right-side">
								<pre class="presentation-code"><code class="hljs" data-trim data-noescape>
<span class="fragment" data-fragment-index="5">import {DateFormatValueConverter} from
	'../src/date-format';</span>
<span class="fragment" data-fragment-index="6">class AppConfigStub {
  getDateFormat() {
    return 'MMMM Do YYYY';
  }
}</span>
<span class="fragment" data-fragment-index="7">describe('Date Format', () => {</span>
  <span class="fragment" data-fragment-index="8">let dateFormat;
  let mockAC;
  beforeEach(() => {
    mockAC = new AppConfigStub();
    dateFormat =
			new DateFormatValueConverter(mockAC);
  });</span>
  <span class="fragment" data-fragment-index="9">it('Returns a formatted date', () => {
    let value = '2016-04-30';
    expect(dateFormat.toView(value))
			.toEqual('April 30th 2016');
  });</span>
<span class="fragment" data-fragment-index="7">});</span>
								</code></pre>
							</div>
						</div>
						<p class="fragment" data-fragment-index="10">
							Can also use Jasmine's <a href="http://jasmine.github.io/2.0/introduction.html#section-Spies">spyOn</a> to track and verify mocked calls.
						</p>
					</section>

          <section>
            <h2>Unit Test Tooling</h2>
						<img src="images/jasmine-logo.png" alt="jasmine logo" class="no-border">
						<img src="images/karma-logo.png" width="160" height="160" alt="karma logo" class="no-border">
            <ul>
              <li class="fragment">Jasmine to write the tests.</li>
              <li class="fragment">Karma to run the tests, with plugins:</li>
							<ul>
								<li class="fragment"><a href="https://github.com/babel/karma-babel-preprocessor">karma-babel-preprocessor</a> for transpilation of src and test files.</li>
	              <li class="fragment"><a href="https://github.com/Workiva/karma-jspm">karma-jspm</a> for dynamic loading of src and test modules.</li>
								<li class="fragment"><a href="https://github.com/aurelia/skeleton-navigation/blob/master/skeleton-es2016/karma.conf.js">Example</a> Karma configuration for Aurelia.</li>
							</ul>
            </ul>
          </section>

					<section data-state="side-by-side">
						<h2>End to End Testing</h2>
						<h3>Challenges with Selenium</h3>
						<div class="container">
							<div class="left-side">
								<img src="images/selenium-beast.jpg" alt="selenium is a beast" class="no-border">
							</div>
							<div class="right-side">
								<ul>
									<li class="fragment">Tests are brittle due to dependency on DOM and CSS.</li>
									<li class="fragment">Browser interaction is asynchronous.</li>
									<li class="fragment">Complexity for SPA's detecting when page is loaded, routing is complete.</li>
								</ul>
							</div>
						</div>
					</section>

					<section data-state="side-by-side-rescue">
						<h2>Protractor to the rescue!</h2>
						<h3>End to end test framework</h3>
						<div class="container">
							<div class="left-side">
								<img src="images/squirrel-to-the-rescue-large.jpg" class="no-border" alt="squirrel to the rescue">
							</div>
							<div class="right-side">
								<ul>
									<li class="fragment">Developed for Angular, but also supports Aurelia with a plugin.</li>
									<li class="fragment">Makes working with Selenium easier.</li>
									<li class="fragment">Browser interactions return promises, Jasmine assertions patched to wait for resolve</li>
									<li class="fragment">Knows when Aurelia page has finished loading.</li>
									<li class="fragment">Locators to find elements by binding rather than DOM positioning.</li>
								</ul>
							</div>
						</div>
					</section>

					<section>
						<h2>Welcome Page</h2>
								<pre class="presentation-code"><code class="hbs" data-trim>
<input type="text" value.bind="firstName" placeholder="first name">
<input type="text" value.bind="lastName" placeholder="last name">
<div class="full-name"> ${fullName | upper}</div>
								</code></pre>
						<iframe style="width: 90%; height: 300px" src="http://embed.plnkr.co/livWB7" frameborder="0"></iframe>
					</section>

					<section data-state="side-by-side">
						<h2>Welcome Page E2E Test</h2>
						<pre class="presentation-code"><code class="hbs" data-trim>
<input type="text" value.bind="firstName" placeholder="first name">
<input type="text" value.bind="lastName" placeholder="last name">
<div class="full-name"> ${fullName | upper}</div>
						</code></pre>
						<div class="container">
							<div class="left-side">
								<ul>
									<li class="fragment" data-fragment-index="1">Describe block</li>
									<li class="fragment" data-fragment-index="2">Navigate to app in beforeEach</li>
									<li class="fragment" data-fragment-index="3">Add a test</li>
									<li class="fragment" data-fragment-index="4">Find elements by binding</li>
									<li class="fragment" data-fragment-index="5">Make assertions</li>
								</ul>
							</div>
							<div class="right-side">
								<pre class="presentation-code"><code class="hljs" data-trim data-noescape>
<span class="fragment" data-fragment-index="1">describe('Welcome Page', () => {</span>

	<span class="fragment" data-fragment-index="2">beforeEach(() => {
		browser.loadAndWaitForAureliaPage(
			'http://localhost:9000');
	});</span>

	<span class="fragment" data-fragment-index="3">it('Displays full name', () => {</span>
		<span class="fragment" data-fragment-index="4">element(by.valueBind('firstName'))
			.clear().sendKeys('John');
		element(by.valueBind('lastName'))
			.clear().sendKeys('Smith');</span>
		<span class="fragment" data-fragment-index="5">expect(element(by.css('.full-name'))
			.getText())
			.toEqual('JOHN SMITH');</span>
	<span class="fragment" data-fragment-index="3">});</span>
<span class="fragment" data-fragment-index="1">});</span>
								</code></pre>
							</div>
						</div>

					</section>

					<section data-state="page-object" data-transition="none" >
						<h2>Page Objects</h2>
						<p>
							From the <a href="https://github.com/angular/protractor/blob/master/docs/page-objects.md">Protractor Documentation</a>
						</p>
						<blockquote cite="https://github.com/angular/protractor/blob/master/docs/page-objects.md">
							<i class="fa fa-quote-left fa-3x fa-pull-left fa-border" aria-hidden="true"></i>
							When writing end-to-end tests, a common pattern is to use Page Objects.
							Page Objects help you write cleaner tests by encapsulating information about the elements on your application page.
							A Page Object can be reused across multiple tests, and if the template of your application changes,
							you only need to update the Page Object.
						</blockquote>
					</section>

					<section data-transition="none"
						data-background-transition="none"
						data-background-image="images/say-what.gif"
						data-background-size="80%">
					</section>

					<!-- TODO fragment this for explanation of each step -->
					<section data-state="side-by-side">
						<h2>Page Object Example</h2>
						<div class="container">
							<div class="left-side">
								<pre class="presentation-code"><code class="hljs" data-trim>
export class PageObjectWelcome {
	constructor() { }

	setFirstName(value) {
		return element(by.valueBind('user.firstName'))
			.clear().sendKeys(value);
	}
	setLastName(value) {
		return element(by.valueBind('user.lastName'))
			.clear().sendKeys(value);
	}

	register() {
		element(by.clickTrigger('register()'))
			.click();
	}
}
								</code></pre>
							</div>
							<div class="right-side">
								<pre class="fragment 	presentation-code"><code class="hljs" data-trim>
import {PageObjectWelcome} from './welcome.po';

describe('Welcome Page', () => {
	let poWelcome;

	beforeEach(() => {
		poWelcome = new PageObjectWelcome();
	});

	it('Allows user to register', () => {
		poWelcome.setFirstName('Joe');
		poWelcome.setLastName('Smith');
		poWelcome.register();
		...
	})
});
								</code></pre>
							</div>
						</div>
						<ul>
							<li class="fragment">Test is more legible.</li>
							<li class="fragment">If template changes, only need to change PO, not every test.</li>
						</ul>
					</section>

					<section data-state="side-by-side">
						<h2>Still some work to be done</h2>
						<div class="container">
							<div class="left">
								<img src="images/lego-house-work-in-progress-large.jpg" width="700px" class="no-border" alt="work in progress">
							</div>
							<div class="right">
								<ul>
									<li class="fragment">No "wait for binding", workaround is <code>browser.sleep(200)</code></li>
									<li class="fragment">No repeater binding</li>
									<li class="fragment">No binding for string interpolation</li>
									<li class="fragment">Skeleton plugin is limited, I've written additional locators <a href="https://gist.github.com/danielabar/8b25a328f5aa974827e648f5ab8c4979">here</a>.</li>
								</ul>
							</div>
						</div>
					</section>
				</section>
				<!-- END Daniela: Testing -->

				<!-- BEGIN Daniela: Gotchas -->
				<section data-transition="convex">
					<section data-transition="fade" data-state="subsection-start" data-background="images/gotchas.gif" data-background-size="80%">
						<h2 class="extra-large">Gotchas</h2>
					</section>
					<section>
						<h2>It's new...</h2>
						<ul>
							<li class="fragment">Still in beta &rarr; moving target</li>
							<li class="fragment">Documentation is a work in progress</li>
							<li class="fragment">Not a lot of Q &amp; A on Stack Overflow</li>
							<li class="fragment">
								<div>JSPM is new and quirky (recommended package manager and module loader)</div>
								<small>
									<ul>
										<li>JSPM link and associated transitive dependencies are flakey</li>
										<li>Implicitly pulls in all transitive dependencies</li>
									</ul>
								</small>
							</li>
							<li class="fragment">Bundling and optimization still needs work</li>
						</ul>
					</section>
				</section>
				<!-- END Daniela: Gotchas -->

				<!-- Wrap up / Q&A -->
				<section>
					<h2>Q &amp; A</h2>
				</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				width: 1300,
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'socket.io/socket.io.js', async: true },
			 		{ src: 'plugin/notes-server/client.js', async: true }
				]
			});

		</script>
		<script src="js/custom.js"></script>
	</body>
</html>
